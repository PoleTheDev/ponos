import type { IndexedIterable } from 'immutable'

type ConcurrencyOption = {
  concurrency: number,
};

declare class Promise<R> {
  static TimeoutError: typeof Error;

  static bind(ctx: any): Promise<void>;
  static delay(ms: number): Promise<void>;
  static delay<T>(value: T|Promise<T>, ms: number): Promise<T>;
  static fromCallback<T>(fn: (fn: (error: ?Error, value?: T) => void) => void): Promise<T>;
  static map<T, U, Elem: Promise<T> | T>(
  Promises: Array<Elem> | IndexedIterable<Elem>, // extended for immutable
    mapper: (item: T, index: number, arrayLength: number) => U,
    options?: ConcurrencyOption
  ): Promise<Array<U>>;
  static reject<T>(error?: any): Promise<T>;
  static resolve<T>(object?: Promise<T> | T): Promise<T>;
  static try<T>(fn: () => T|Promise<T>, args: ?Array<any>, ctx: ?any): Promise<T>;

  asCallback<T>(fn: (error: ?Error, value: T) => void): void;
  constructor(callback: (
    resolve: (result?: Promise<R> | R) => void,
    reject: (error?: any) => void
  ) => mixed): void;
  bind(ctx: any): Promise<R>;
  catch<U>(onReject?: (error: any) => ?Promise<U> | U): Promise<U>;
  delay(ms: number): Promise<R>;
  finally<T>(onDone?: (value: R) => mixed): Promise<T>;
  map<T, U>(mapper: (item: T, index: number, arrayLength: number) => Promise<U> | U, options?: ConcurrencyOption): Promise<Array<U>>;
  return<T>(value: T): Promise<T>;
  timeout(ms: number, message?: string): Promise<R>;
  then<U>(onFulfill?: (value: R) => Promise<U> | U, onReject?: (error: any) => Promise<U> | U): Promise<U>;
}

declare module 'bluebird' {
  declare var exports: typeof Promise;
}

export { Promise }
